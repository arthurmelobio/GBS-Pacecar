#!/usr/bin/perl

# GBS-PaceCar: A GBS read simulator to put your de novo GBS pipeline through the paces!
#
# Authors: Arthur Melo & Iago Hale
# Department of Agriculture, Nutrition, and Food Systems, University of New Hampshire, Durham, NH, 03824
# September 2018
#
# A detailed description of this tool can be found at https://github.com/halelab/GBS-PaceCar
# 
# For help: perl GBS-Pacecar.pl help

use strict;
use warnings;
use Getopt::Long qw(GetOptions);

my $function = $ARGV[0];
my ($Nreads,$SNP_freq,$indel_freq,$MinReadL,$MaxReadL,$Genos,$MinD,$MaxD,$barcodes);
my @ReadsAvgLen = ();
my $ReadAmount = 0;

#########################################
# Setting the default parameters values
#########################################
$Nreads = 1000;		 $SNP_freq = 0.25;
$indel_freq = 0.1;	 $MinReadL = 32;
$MaxReadL = 150;	 $Genos = 25;
$MinD = 20;			 $MaxD = 30;

GetOptions(
'n=s' => \$Nreads,           # value: the number of desired GBS fragments (loci) in the genome
'snps=s' => \$SNP_freq,      # value (proportion): proportion of fragments carrying a SNP
'indels=s' => \$indel_freq,  # value (proportion): proportion of fragments carrying an indel
'minl=s' => \$MinReadL,      # value: minimum acceptable GBS fragment length
'maxl=s' => \$MaxReadL,      # value: maximum read length, determined by sequencer (e.g. 150 bp)
'g=s' => \$Genos,            # value: number of individuals (genotypes) in the population
'mind=s' => \$MinD,          # value: minimum read depth for a given GBS fragment in a given individual
'maxd=s' => \$MaxD,          # value: maximum read depth for a given GBS fragment in a given individual
'b=s' => \$barcodes,         # text file of barcodes and individual ID's: required for "Raw" and "Both" functions
);

######################
# The help function
######################
if ( (! defined $function) or ($function eq "h") or ($function eq "help") )  {
	print "\n\nProgram: GBS-Pacecar\n"
	."A GBS read simulator (single-end reads with SNPs and indels) to put your de novo GBS pipeline through the paces!).\n\n"
	."Authors: Arthur Melo & Iago Hale, University of New Hampshire.\nhttps://github.com/halelab/GBS-PaceCar\n\n"
	."Usage: perl GBS-Pacecar.pl <commands> [options]\n\n"
	."Commands (case sensitive):\n"
	."Parsed: the simulated reads will be demultiplexed across the number of genotypes declared by -g.\n"
	."Raw: all simulated reads will be compressed into a single FASTQ file of raw reads, as generated by CASAVA. Requires barcode ID text file (-b).\n"
	."Both: creates both parsed and raw outputs. Requires barcode ID text file (-b).\n\n"
	."Options:\n"
	."-b <barcode.txt>: barcode ID file. Required for Raw and Both outputs (see Commands)\n"
	."-n 1000: base number of GBS fragments in the genome\n"
	."-snps 0.25: proportion of base GBS fragments carrying a SNP\n"
	."-indels 0.10: proportion of base GBS fragments carrying an indel\n"
	."-minl 32: minimum acceptable GBS fragment\n"
	."-maxl 150: maximum read length, determined by sequencer (e.g. 150 bp)\n"
	."-g 25: number of individuals in the population\n"
	."-mind 20: minimum read depth for a given GBS fragment in a given individual\n"
	."-maxd 30: maximum read depth for a given GBS fragment in a given individual\n\n";
	goto FINAL;

} else {

	########################################
	# Create -n unique genomic fragments of length -minl to -maxl
	########################################
	print "GBS-PaceCar is simulating single-end reads...\n";
	my @Base_Reads = ();
	my @chars = ("A", "C", "G", "T");
	for ( my $i=1; $i <= $Nreads; $i++ ) {
		my $header = "@" . "HSQ-7001360:68:H8DUYADXX:1:1101:" . "$i";
		my $string = "G";
		my $length = $MinReadL + int( rand ( $MaxReadL - $MinReadL ) );
		$string .= $chars[rand @chars] for 1..$length;
	
		# Remove confounding PstI and MspI restriction sites from random strings
		$string =~ s/CTGCAG/CTAAAG/g;
		$string =~ s/GACGTC/GAAATC/g;
		$string =~ s/CCGG/CAAG/g;
		$string =~ s/GGCC/GAAC/g;	
	
		push @Base_Reads, "$header\n$string\n";
	}

	my @SNP_refs = ();
	my @SNP_alts = ();
	my @indel_refs = ();
	my @indel_alts = ();
	my @no_mutations = ();


	######################
	# Induce SNPs only
	######################
	if ($indel_freq == 0) {
	
		my $SNPreads = int ($SNP_freq * $Nreads);

		for ( my $j = 0; $j <= $SNPreads; $j++ ) {
			push @SNP_refs, $Base_Reads[$j];
		}
		for ( my $l = $SNPreads + 1; $l < $Nreads; $l++ ) {
			push @no_mutations, $Base_Reads[$l];
		}
		undef( @Base_Reads );
	
		my $OutSNPs = "GBS-Pacecar_Induced_SNPs.txt";
		open my $SNP_POS, ">", "$OutSNPs" or die "Can't initialize $_ output file";
		print $SNP_POS "read_ID\tori_seq\tSNP_pos\tRef->SNP\talt_seq\n";

		foreach my $read (@SNP_refs) {
			my @input = split "\n", $read;
			my $header = $input[0];
			my $seq = $input[1];

			my $SNP_Pos = 1 + int ( rand ( length( $seq ) - 1 )) ;
			my $ref_nt = substr $seq, $SNP_Pos, 1;

			my @avail_nts = ();
			foreach my $nt ( @chars ) {
				next if $nt eq "$ref_nt";
				push @avail_nts, $nt;
			}
	
			my $alt_nt = $avail_nts[rand @avail_nts];
			my $pos = $SNP_Pos + 1;
			print $SNP_POS "$header\t$seq\t$pos\t$ref_nt->$alt_nt\t";
			substr $seq, $SNP_Pos, 1, $alt_nt;
			print $SNP_POS "$seq\n";
			push @SNP_alts, "$header\n$seq\n";
		}


	#######################
	# Induce indels only
	#######################
	} elsif ($SNP_freq == 0) {

		my $indelreads = int ($indel_freq * $Nreads);

		for ( my $j = 0; $j <= $indelreads; $j++ ) {
			push @indel_refs, $Base_Reads[$j];
		}
		for ( my $l = $indelreads + 1; $l < $Nreads; $l++ ) {
			push @no_mutations, $Base_Reads[$l];
		}
		undef( @Base_Reads );

	
		my $OutIndels = "GBS-PaceCar_Induced_Indels.txt";
		open my $indel_POS, ">", "$OutIndels" or die "Can't initialize $_ output file";
		print $indel_POS "read ID\tori seq\tindel type\tindel pos\tindel\talt seq\n";

		my @indel_choice = ( "insertion", "deletion");

		foreach my $read ( @indel_refs ) {
			my @input = split "\n", $read;
			my $header = $input[0];
			my $seq = $input[1];
			print $indel_POS "$header\t$seq\t";

			my $choice = $indel_choice[rand @indel_choice];
			my $indel_len = 3 + int(rand(10)); # acceptable range of indel lengths (e.g. 3-10 bp)
			my $indel;
	
			# Insertions
			if ($choice eq "insertion") {
				$indel .= $chars[rand @chars] for 1..$indel_len; # creates the insertion sequence
								
				# Remove confounding PstI and MspI restriction sites that may be created by insertion
				$indel =~ s/CTGCAG/CTAAAG/g;
				$indel =~ s/GACGTC/GAAATC/g;
				$indel =~ s/CCGG/CAAG/g;
				$indel =~ s/GGCC/GAAC/g;	

				my $indel_pos = 2 + int(rand((length $seq) - 2)); # identify insertion position (neither the beginning nor the end of the sequence)
				my $first = substr $seq, 0, $indel_pos;
				my $last = substr $seq, $indel_pos;
				my $new_read = $first . $indel . $last;
				my $pos = $indel_pos + 1;
				push @indel_alts, "$header\n$new_read\n";
				print $indel_POS "Insertion\t$pos\t$indel\t$new_read\n";

			# Deletions
			} elsif ($choice eq "deletion") {
				my $indel_pos = 2 + int(rand((length $seq) - $indel_len - 2)); # identify deletion position
				$indel = substr $seq, $indel_pos, $indel_len;
								
				# Remove confounding PstI and MspI restriction sites that may be created by deletion
				$indel =~ s/CTGCAG/CTAAAG/g;
				$indel =~ s/GACGTC/GAAATC/g;
				$indel =~ s/CCGG/CAAG/g;
				$indel =~ s/GGCC/GAAC/g;	

				my $first = substr $seq, 0, $indel_pos;
				my $last = substr $seq, $indel_pos + $indel_len;
				my $new_read = $first . $last;
				my $pos = $indel_pos + 1;
				push @indel_alts, "$header\n$new_read\n";
				print $indel_POS "Deletion\t$pos\t$indel\t$new_read\n";
			}
		}


	############################
	# Induce SNPs and indels
	############################
	} elsif ( ($SNP_freq != 0) and ($indel_freq != 0) ) {

		my $SNPreads = int ($SNP_freq * $Nreads);
		my $indelreads = int ($indel_freq * $Nreads);

		for ( my $j = 0; $j <= $SNPreads; $j++ ) {
			push @SNP_refs, $Base_Reads[$j];
		}
		for ( my $k = $SNPreads + 1; $k <= $SNPreads + $indelreads; $k++ ) {
			push @indel_refs, $Base_Reads[$k];
		}
		for ( my $l = $SNPreads + $indelreads + 1; $l < $Nreads; $l++ ) {
			push @no_mutations, $Base_Reads[$l];
		}
		undef( @Base_Reads );

		# Induce SNPs

		my $OutSNPs = "GBS-PaceCar_Induced_SNPs.txt";
		open my $SNP_POS, ">", "$OutSNPs" or die "Can't initialize $_ output file";
		print $SNP_POS "read ID\toriginal sequence\tSNP pos\tRef base->SNP\talt sequence\n";

		foreach my $read (@SNP_refs) {
			my @input = split "\n", $read;
			my $header = $input[0];
			my $seq = $input[1];

			my $SNP_Pos = 1 + int ( rand ( length( $seq ) - 1 )) ;
			my $ref_nt = substr $seq, $SNP_Pos, 1;

			my @avail_nts = ();
			foreach my $nt ( @chars ) {
				next if $nt eq "$ref_nt";
				push @avail_nts, $nt;
			}
	
			my $alt_nt = $avail_nts[rand @avail_nts];
			my $pos = $SNP_Pos + 1;
			print $SNP_POS "$header\t$seq\t$pos\t$ref_nt->$alt_nt\t";
			substr $seq, $SNP_Pos, 1, $alt_nt;
			print $SNP_POS "$seq\n";
			push @SNP_alts, "$header\n$seq\n";
		}

		# Induce indels

		my $OutIndels = "GBS-PaceCar_Induced_Indels.txt";
		open my $indel_POS, ">", "$OutIndels" or die "Can't initialize $_ output file";
		print $indel_POS "read ID\toriginal sequence\tindel type\tindel pos\tindel\talt sequence\n";

		my @indel_choice = ( "insertion", "deletion");

		foreach my $read ( @indel_refs ) {
			my @input = split "\n", $read;
			my $header = $input[0];
			my $seq = $input[1];
			print $indel_POS "$header\t$seq\t";

			my $choice = $indel_choice[rand @indel_choice];
			my $indel_len = 1 + int(rand(10)); # acceptable range of indel lengths (e.g. 3-10 bp)
			my $indel;
	
			# Insertions
			if ($choice eq "insertion") {
				$indel .= $chars[rand @chars] for 1..$indel_len; # creates the insertion sequence
				
				# Remove confounding PstI and MspI restriction sites that may be created by insertion
				$indel =~ s/CTGCAG/CTAAAG/g;
				$indel =~ s/GACGTC/GAAATC/g;
				$indel =~ s/CCGG/CAAG/g;
				$indel =~ s/GGCC/GAAC/g;	
				
				my $indel_pos = 2 + int(rand((length $seq) - 2)); # identify insertion position (neither the beginning nor the end of the sequence)
				my $first = substr $seq, 0, $indel_pos;
				my $last = substr $seq, $indel_pos;
				my $new_read = $first . $indel . $last;
				my $pos = $indel_pos + 1;
				push @indel_alts, "$header\n$new_read\n";
				print $indel_POS "Insertion\t$pos\t$indel\t$new_read\n";

			# Deletions
			} elsif ($choice eq "deletion") {
				my $indel_pos = 2 + int(rand((length $seq) - $indel_len - 2)); # identify deletion position
				$indel = substr $seq, $indel_pos, $indel_len;
								
				# Remove confounding PstI and MspI restriction sites that may be created by deletion
				$indel =~ s/CTGCAG/CTAAAG/g;
				$indel =~ s/GACGTC/GAAATC/g;
				$indel =~ s/CCGG/CAAG/g;
				$indel =~ s/GGCC/GAAC/g;	

				my $first = substr $seq, 0, $indel_pos;
				my $last = substr $seq, $indel_pos + $indel_len;
				my $new_read = $first . $last;
				my $pos = $indel_pos + 1;
				push @indel_alts, "$header\n$new_read\n";
				print $indel_POS "Deletion\t$pos\t$indel\t$new_read\n";
			}
		}
	}


	##########################################################
	# Sample alleles to generate genotypes (base FASTQ files)
	##########################################################
	my @Genotypes = ();
	for ( my $i = 1; $i <= $Genos; $i++ ) {
		my $OutName1 = join ".", "Geno","$i","fq";
		my $OutName2 = join ".", "Geno","$i","txt";
		push @Genotypes, $OutName1;
		open my $OUT1, ">", "$OutName1" or die "Can't initialize $_ output file";
		open my $OUT2, ">", "$OutName2" or die "Can't initialize $_ output file";
	
		# Process all monomorphic base GBS fragments
		foreach my $read (@no_mutations) {
			my @input = split "\n", $read;
			my $header = $input[0];
			my $seq = $input[1];
			my $qual = "J" x length $seq;
			print $OUT1 "$read+\n$qual\n$read+\n$qual\n";
		}
	
		# Process all SNP-containing GBS fragments
		for ( my $j = 0; $j <= scalar(@SNP_refs) - 1; $j++ ) {

			my @input = split "\n", $SNP_refs[$j];
			my $seq = $input[1];
			my $qual = "J" x length $seq;

			my $state = int(rand(3));

			# Homozygous for reference read
			if ($state == 0) {
				print $OUT1 "$SNP_refs[$j]+\n$qual\n$SNP_refs[$j]+\n$qual\n";
				print $OUT2 "$state\n";
			}	

			# Heterozygous
			elsif ($state == 1) {
				print $OUT1 "$SNP_refs[$j]+\n$qual\n$SNP_alts[$j]+\n$qual\n";
				print $OUT2 "$state\n";
			}
		
			# Homozygous for alternate read
			elsif ($state == 2) {
				print $OUT1 "$SNP_alts[$j]+\n$qual\n$SNP_alts[$j]+\n$qual\n";
				print $OUT2 "$state\n";
			}
		}

		# Process all indel-containing GBS fragments
		for ( my $k = 0; $k <= scalar(@indel_refs) - 1; $k++ ) {

			my @ref_input = split "\n", $indel_refs[$k];
			my $ref_seq = $ref_input[1];
			my @alt_input = split "\n", $indel_alts[$k];
			my $alt_seq = $alt_input[1];

			my $ref_qual = "J" x length $ref_seq;
			my $alt_qual = "J" x length $alt_seq;

			my $state = int(rand(3));

			# Homozygous for base read
			if ($state == 0) {
				print $OUT1 "$indel_refs[$k]+\n$ref_qual\n$indel_refs[$k]+\n$ref_qual\n";
				print $OUT2 "$state\n";
			}	

			# Heterozygous
			elsif ($state == 1) {
				print $OUT1 "$indel_refs[$k]+\n$ref_qual\n$indel_alts[$k]+\n$alt_qual\n";
				print $OUT2 "$state\n";
			}
		
			# Homozygous for alternate read
			elsif ($state == 2) {
				print $OUT1 "$indel_alts[$k]+\n$alt_qual\n$indel_alts[$k]+\n$alt_qual\n";
				print $OUT2 "$state\n";
			}
		}
		close $OUT1;
		close $OUT2;
	}

	########################################################
	# Introduce random sequencing error and depth variation
	########################################################
	my $l = 1;

	foreach my $ind ( @Genotypes ) {
		open my $IN, "<", "$ind" or die "Can't load $ind file";
		my $OutName = join ".", (join "","Genotype","$l"),"R1","fq","gz";
		open my $OUT, " | gzip > $OutName" or die "Can't open $_ file\n";
		$l++;

		my @R1read;
		my @R1reads;
		my $i = 1;
		while(<$IN>) {
			if ($i % 4 != 0) {
				push @R1read, $_;
				$i++;
			} else {
				push @R1read, $_;
				chomp (@R1read);
				push @R1reads, [ @R1read ];
				@R1read = ();
				$i++;
			}
		}

		for (my $k = 0; $k <= scalar @R1reads - 1; $k++) {		
		
			my $depth = ($MinD/2) + int(rand( ($MaxD/2) - ($MinD/2)));
			$ReadAmount = $ReadAmount + $depth;
		
			for (my $j = 1; $j <= $depth; $j++) {

				my $true_seq = $R1reads[$k][1];

				my $ErrorPos = int(rand(length($true_seq)));
				my $true_nt = substr $true_seq, $ErrorPos, 1;
				my @avail_nts = ();
				foreach my $nt (@chars) {
					next if $nt eq "$true_nt";
					push @avail_nts, $nt;
				}

				my $error_nt = $avail_nts[rand @avail_nts];
				substr $true_seq, $ErrorPos, 1, $error_nt;
				my $header = "$R1reads[$k][0]" . "." . "$j" . " " . "1:N:0:";
				print $OUT "$header\n$true_seq\n+\n$R1reads[$k][3]\n";
			
				my $read_len = length $R1reads[$k][1];
				push @ReadsAvgLen, $read_len;

			}
		}
	}
}

###########################
# Print Parsed output only
###########################
if ($function eq "Parsed") {
	system ( "rm Geno*.txt Geno*.fq" );
	print "DONE.\n";
	
	my $sum = 0;
	$sum += $_ for @ReadsAvgLen;
	
	print "\n# Summary of simulated reads:\n"
	."Function = Parsed = demultiplexed sequence files\n"
	."Total base GBS fragments = $Nreads\n"
	."GBS fragments carrying a SNP = ", sprintf("%.0f",($SNP_freq * $Nreads)), "\n"
	."GBS fragments carrying an indel = ", sprintf("%.0f",($indel_freq * $Nreads)), "\n"
	."Total number of simulated reads = ", $ReadAmount, "\n"
	."Minimum read length = $MinReadL\n"
	."Maximum read length = $MaxReadL\n"
	."Minimum read depth = $MinD\n"
	."Maximum read depth = $MaxD\n"
	."Number of genotypes = $Genos\n"
	."Average number of reads per genotype = ", sprintf("%.2f",($ReadAmount/$Genos)), "\n"
	."Average length (bp) of the simulated GBS fragments = ", sprintf("%.2f",($sum/scalar @ReadsAvgLen)), "\n"
	."Realized error rate = ", sprintf("%.2f",(($ReadAmount/$sum)*100)), "%\n\n";
	
####################################
# Print both Parsed and Raw outputs
####################################
} elsif ($function eq "Both") {
	
	my @barcodes = ();
	my @genotypes = ();
	open my $BAR, "<", "$barcodes" or die "Can't find $barcodes file\n";
	while ( <$BAR> ) {
		my $input = $_;
		chomp $input;
		my @input = split ("\t", $input);
		push @barcodes, $input[0];
		push @genotypes, $input[1];
	}
	close $BAR;

	my $output = "GBS-Pacecar_R1_001.fastq";
	open my $OUT, ">", "$output" or die "Can't initialize $_ output file\n";

	my @nts = ("A", "C", "G", "T");
	my $geno_count = 0;

	foreach my $genotype ( @genotypes ) {
		my $input = join (".", "$genotype","R1","fq","gz");
	
		if ( -e $input ) {
			open my $IN, '-|', 'gzip', '-dc', $input or die "Can't open file $_!\n";
			my $barcode = $barcodes[$geno_count];

			my @R1read;
			my @R1reads;
			my $i = 1;
			while( <$IN> ) {
				if ($i % 4 != 0) {
					push @R1read, $_;
					$i++;
				} else {
					push @R1read, $_;
					chomp (@R1read);
					push @R1reads, [ @R1read ];
					@R1read = ();
					$i++;
				}
			}

			for (my $k = 0; $k <= scalar @R1reads - 1; $k++) {

				my $header = $R1reads[$k][0];
				my $seq = $R1reads[$k][1];
			
				my $new_seq = join ('', $barcode, "TGCA", $seq, "CCGAGATCGGAAGAGCGTCGTG");
				my $seq_len = length $new_seq;
				my $qual = "J" x $seq_len;
				
				if ($seq_len < $MaxReadL) { # If read are shorter than $MaxReadL, complete to $MaxReadL with low quality nucleotides
					my $shortfall = $MaxReadL - $seq_len;
					my $seq_add_on;
					$seq_add_on .= $nts[rand @nts] for 1..$shortfall;
					my $qual_add_on = "!" x $shortfall;
					my $final_seq = join ('', $new_seq, $seq_add_on);
					my $final_qual = join ('', $qual, $qual_add_on);
				} elsif ($seq_len > $MaxReadL) { # Trim based $MaxReadL
					my $final_seq  = substr $new_seq, 0, $MaxReadL;
					my $final_qual = substr $qual, 0, $MaxReadL;
					print $OUT "$header\n$final_seq\n+\n$final_qual\n";	
				} elsif ($seq_len == $MaxReadL) { # Just print
					print $OUT "$header\n$new_seq\n+\n$qual\n";
				}
			}
			$geno_count++;
		
		} else {
			last;
		}
	}
	system ( " gzip GBS-Pacecar_R1_001.fastq " );
	system ( "rm Geno*.txt Geno*.fq" );
	print "DONE.\n\n";
	
	my $sum = 0;
	$sum += $_ for @ReadsAvgLen;
	
	print "\n# Summary of simulated reads:\n"
	."Function = Both = both Parsed and Raw outputs\n"
	."Total base GBS fragments = $Nreads\n"
	."GBS fragments carrying a SNP = ", sprintf("%.0f",($SNP_freq * $Nreads)), "\n"
	."GBS fragments carrying an indel = ", sprintf("%.0f",($indel_freq * $Nreads)), "\n"
	."Total number of simulated reads = ", $ReadAmount, "\n"
	."Minimum read length = $MinReadL\n"
	."Maximum read length = $MaxReadL\n"
	."Minimum read depth = $MinD\n"
	."Maximum read depth = $MaxD\n"
	."Number of genotypes = $Genos\n"
	."Average number of reads per genotype = ", sprintf("%.2f",($ReadAmount/$Genos)), "\n"
	."Average length (bp) of the simulated GBS fragments = ", sprintf("%.2f",($sum/scalar @ReadsAvgLen)), "\n"
	."Realized error rate = ", sprintf("%.2f",(($ReadAmount/$sum)*100)), "%\n\n";
	
########################
# Print Raw output only
########################
} elsif ($function eq "Raw") {
	
	my @barcodes = ();
	my @genotypes = ();
	open my $BAR, "<", "$barcodes" or die "Can't find $barcodes file\n";
	while ( <$BAR> ) {
		my $input = $_;
		chomp $input;
		my @input = split ("\t", $input);
		push @barcodes, $input[0];
		push @genotypes, $input[1];
	}
	close $BAR;

	my $output = "GBS-Pacecar_R1_001.fastq";
	open my $OUT, ">", "$output" or die "Can't initialize $_ output file\n";

	my @nts = ("A", "C", "G", "T");
	my $geno_count = 0;

	foreach my $genotype ( @genotypes ) {
		my $input = join (".", "$genotype","R1","fq","gz");
	
		if ( -e $input ) {
			open my $IN, '-|', 'gzip', '-dc', $input or die "Can't open file $_!\n";
			my $barcode = $barcodes[$geno_count];

			my @R1read;
			my @R1reads;
			my $i = 1;
			while( <$IN> ) {
				if ($i % 4 != 0) {
					push @R1read, $_;
					$i++;
				} else {
					push @R1read, $_;
					chomp (@R1read);
					push @R1reads, [ @R1read ];
					@R1read = ();
					$i++;
				}
			}

			for (my $k = 0; $k <= scalar @R1reads - 1; $k++) {

				my $header = $R1reads[$k][0];
				my $seq = $R1reads[$k][1];
			
				my $new_seq = join ('', $barcode, "TGCA", $seq, "CCGAGATCGGAAGAGCGTCGTG");
				my $seq_len = length $new_seq;
				my $qual = "J" x $seq_len;
				
				if ($seq_len < $MaxReadL) { # If read are shorter than $MaxReadL, complete to $MaxReadL with low quality nucleotides
					my $shortfall = $MaxReadL - $seq_len;
					my $seq_add_on;
					$seq_add_on .= $nts[rand @nts] for 1..$shortfall;
					my $qual_add_on = "!" x $shortfall;
					my $final_seq = join ('', $new_seq, $seq_add_on);
					my $final_qual = join ('', $qual, $qual_add_on);
					print $OUT "$header\n$final_seq\n+\n$final_qual\n";
				} elsif ($seq_len > $MaxReadL) { # Trim based $MaxReadL
					my $final_seq  = substr $new_seq, 0, $MaxReadL;
					my $final_qual = substr $qual, 0, $MaxReadL;
				} elsif ($seq_len == $MaxReadL) { # Just print
					print $OUT "$header\n$new_seq\n+\n$qual\n";
				}
			}
			$geno_count++;
		
		} else {
			last;
		}
	}
	system ( " gzip GBS-Pacecar_R1_001.fastq " );
	system ( "rm Genotype*.R1.fq.gz Geno*.txt Geno*.fq" );
	print "DONE.\n\n";
	
	my $sum = 0;
	$sum += $_ for @ReadsAvgLen;
	
	print "\n# Summary of simulated reads:\n"
	."Function = Raw = single FASTQ file of raw reads, as generated by CASAVA.\n"
	."Total base GBS fragments = $Nreads\n"
	."GBS fragments carrying a SNP = ", sprintf("%.0f",($SNP_freq * $Nreads)), "\n"
	."GBS fragments carrying an indel = ", sprintf("%.0f",($indel_freq * $Nreads)), "\n"
	."Total number of simulated reads = ", $ReadAmount, "\n"
	."Minimum read length = $MinReadL\n"
	."Maximum read length = $MaxReadL\n"
	."Minimum read depth = $MinD\n"
	."Maximum read depth = $MaxD\n"
	."Number of genotypes = $Genos\n"
	."Average number of reads per genotype = ", sprintf("%.2f",($ReadAmount/$Genos)), "\n"
	."Average length (bp) of the simulated GBS fragments = ", sprintf("%.2f",($sum/scalar @ReadsAvgLen)), "\n"
	."Realized error rate = ", sprintf("%.2f",(($ReadAmount/$sum)*100)), "%\n\n";
}

FINAL:
exit;
